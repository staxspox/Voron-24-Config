# # # Klipper Adaptive Purging - Line # # #

# This macro will parse information from objects in your gcode and create a nearby purge!
# For successful purging, you may need to configure:
# 
# [extruder]
# ...
# max_extrude_cross_section: 5

[gcode_macro LINE_PURGE]
description: A purge macro that adapts to be near your actual printed objects

variable_adaptive_enable: True      # Change to False if you'd like the purge to be in the same spot every print
variable_z_height: 0.4              # Height above the bed to purge
variable_purge_amount: 40   #20        # Amount of filament in millimeters to purge
variable_line_length: 60    #40        # Overall desired length of purge line in millimeters, around 1/5th of X axis length is a good starting value
variable_flow_rate: 20      #12        # Desired flow rate in mm3/s (Around 12 for standard flow hotends, around 24 for high flow hotends)
variable_x_default: 15             # Default X location to purge. If adaptive_enable is True, this is overwritten
variable_y_default: 15            # Default Y location to purge. If adaptive_enable is True, this is overwritten
variable_distance_to_object_y: 20   # Y distance in millimeters away from the print area for purging. Must be less than or equal to y_default if adaptive_enable is False

### This section is for those who are using Moonraker's Update Manager for KAMP, or want a more verbose macro. ###

variable_display_parameters: True   # Display macro paramters in the console, useful for debugging the SETUP_LINE_PURGE call, or more verbosity.

gcode:

    {% if display_parameters == True %}
      { action_respond_info("adaptive_enable : %d" % (adaptive_enable))  }
      { action_respond_info("z_height        : %f" % (z_height))  }
      { action_respond_info("purge_amount    : %f" % (purge_amount))  }
      { action_respond_info("line_length     : %f" % (line_length))  }
      { action_respond_info("flow_rate       : %f" % (flow_rate))  }
      { action_respond_info("x_default       : %f" % (x_default))  }
      { action_respond_info("y_default       : %f" % (y_default))  }
      { action_respond_info("distance_to_object_y : %f" % (distance_to_object_y))  }
    {% endif %}

    {% if adaptive_enable == True %}
        {% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
        {% set x_origin = (all_points | map(attribute=0) | min | default(x_default)) %}
        {% set y_origin = (all_points | map(attribute=1) | min | default(y_default)) %}
        {% set x_origin = ([x_origin, 0] | max) %}
        {% set y_origin = ([y_origin, 0] | max) %}
    {% else %}
        {% set x_origin = x_default | float %}
        {% set y_origin = y_default | float %}
    {% endif %}
    {% set nozzle_dia = printer.configfile.config.extruder.nozzle_diameter | float %}
    {% set cross_section = nozzle_dia * z_height | float %}
    {% set purge_move_speed = (cross_section * flow_rate) * 60 | float %}
    {% set travel_speed = 3500 | float %}

    G92 E0                                                                              # Reset extruder
    G0 F{travel_speed}                                                                  # Set travel speed
    G90                                                                                 # Absolute positioning
    G0 X{x_origin} Y{y_origin - distance_to_object_y}                                   # Move to purge position
    G0 Z{z_height}                                                                      # Move to purge Z height
    M83                                                                                 # Relative extrusion mode
    G1 X{x_origin + line_length} E{purge_amount} F{purge_move_speed}                    # Purge line
    G1 E-.5 F2100                                                                       # Retract
    G92 E0                                                                              # Reset extruder distance
    M82                                                                                 # Absolute extrusion mode
    G0 Z{z_height * 2} F{travel_speed}                                                  # Z hop

[gcode_macro SETUP_LINE_PURGE]
gcode:
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=display_parameters   VALUE={params.DISPLAY_PARAMETERS|default(True)|int}
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=adaptive_enable   VALUE={params.ADAPTIVE_ENABLE|default(True)|int}
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=z_height      VALUE={params.Z_HEIGHT|default(0.4)|float}
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=purge_amount  VALUE={params.PURGE_AMOUNT|default(40)|float}
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=line_length  VALUE={params.LINE_LENGTH|default(50)|float}
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=flow_rate     VALUE={params.FLOW_RATE|default(12)|float}
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=x_default     VALUE={params.X_DEFAULT|default(10)|float}
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=y_default     VALUE={params.Y_DEFAULT|default(10)|float}
    SET_GCODE_VARIABLE MACRO=LINE_PURGE  VARIABLE=distance_to_object_y     VALUE={params.DISTANCE_TO_OBJECT_Y|default(10)|float}

#------------------------------------------------------------------------------------------

[gcode_macro PRIMELINE]
gcode:
    # Base macro parameters
    {% set prime_line_length = params.LINE_LENGTH|default(45)|float %}
    {% set prime_line_purge_distance = params.PURGE_LENGTH|default(30)|float %}
    {% set prime_line_flowrate = params.FLOWRATE|default(10)|float %}
    {% set prime_line_height = params.LINE_HEIGHT|default(0.6)|float %}
    {% set prime_line_adaptive = params.ADAPTIVE_MODE|default(1)|int %}
    {% set prime_line_margin = params.LINE_MARGIN|default(5.0)|float %} # Used only in adaptive mode
    
    # If the SIZE parameter is defined and not a dummy placeholder, we use it to do the adaptive bed mesh logic
    {% set coordinatesFound = false %}
    {% if params.SIZE is defined and params.SIZE != "0_0_0_0" %}
        {% set xMinSpec, yMinSpec, xMaxSpec, yMaxSpec = params.SIZE.split('_')|map('trim')|map('int') %}
        {% set coordinatesFound = true %}
    {% elif printer.exclude_object is defined %}
        {% if printer.exclude_object.objects %}
            # Else if SIZE is not defined, we fallback to use the [exclude_object] tags
            # This method is derived from Kyleisah KAMP repository: https://github.com/kyleisah/Klipper-Adaptive-Meshing-Purging)
            {% set eo_points = printer.exclude_object.objects|map(attribute='polygon')|sum(start=[]) %}
            {% set xMinSpec = eo_points|map(attribute=0)|min %}
            {% set yMinSpec = eo_points|map(attribute=1)|min %}
            {% set xMaxSpec = eo_points|map(attribute=0)|max %}
            {% set yMaxSpec = eo_points|map(attribute=1)|max %}
            {% set coordinatesFound = true %}
        {% endif %}
    {% endif %}

    # We get the default prime line position parameters
    {% set prime_line_x, prime_line_y = 5, 2.5|map('float') %}
    {% set prime_line_x = params.START_X|default(prime_line_x)|float %}
    {% set prime_line_y = params.START_Y|default(prime_line_y)|float %}
    {% set prime_line_direction = params.LINE_DIRECTION|default("X")|string|upper %}

    {% set center_x, center_y = [printer.toolhead.axis_maximum.x / 2, printer.toolhead.axis_maximum.y / 2]|map("float") %}
    
    # If first layer coordinates are retrieved and adaptive mode is enabled, then we replace the coordinates to
    # do an adaptive purge while being careful to have the line stay on the bed when the first layer
    # is in an opposite bed quadrant than the prime line initial coordinates (due to mirrored coordinates from center axes)...
    {% if coordinatesFound and prime_line_adaptive == 1 %}
        {% set prime_line_x = 2*center_x - prime_line_x if (prime_line_x > center_x and xMaxSpec < center_x) or (prime_line_x < center_x and xMinSpec > center_x) 
                               else prime_line_x %}
        {% set prime_line_y = 2*center_y - prime_line_y if (prime_line_y > center_y and yMaxSpec < center_y) or (prime_line_y < center_y and yMinSpec > center_y) 
                               else prime_line_y %}
        {% set prime_line_x = [[prime_line_x, xMinSpec - prime_line_margin]|max, xMaxSpec + prime_line_margin]|min %}
        {% set prime_line_y = [[prime_line_y, yMinSpec - prime_line_margin]|max, yMaxSpec + prime_line_margin]|min %}
    {% endif %}

    # Choose the way of printing the primeline (in + or -) alongside the direction to avoid going outside the bed boundaries
    {% set prime_line_way = -1 if (prime_line_direction == "X" and prime_line_x > center_x) or (prime_line_direction == "Y" and prime_line_y > center_y) else 1 %}

    {% set St = 350 * 60 %}
    {% set Sz = 15 * 60 %}
    {% set verbose = True %}

    {% set klippain_mmu_enabled = False %}
    {% set filament_sensor_enabled = False %}
    {% set re_enable_filament_sensor = 0 %}

    {% set max_extrude_cross_section = printer["configfile"].config["extruder"]["max_extrude_cross_section"]|float %}
    {% set filament_diameter = printer["configfile"].config["extruder"]["filament_diameter"]|float %}
    
    # We first compute the width of the prime line
    {% set purge_volume = prime_line_purge_distance * 3.14159 * (filament_diameter / 2)**2 %}
    {% set line_width = purge_volume / (prime_line_height * prime_line_length) %}

    # Then we check that the prime line cross section will not be problematic (exceeding Klipper max_extrude_cross_section)
    # or, if it's the case, we warn the user and add a correction to the length of filament to be purged
    {% if (prime_line_height * line_width) > max_extrude_cross_section %}
        {% if verbose %}
            {action_respond_info("The prime_line_purge_distance of %.4f mm is too high and will exceed the max_extrude_cross_section!" % prime_line_purge_distance)}
        {% endif %}
        {% set prime_line_purge_distance = 0.98 * (max_extrude_cross_section * prime_line_length) / (3.14159 * (filament_diameter / 2)**2) %}
        {% set purge_volume = prime_line_purge_distance * 3.14159 * (filament_diameter / 2)**2 %}
        {% set line_width = purge_volume / (prime_line_height * prime_line_length) %}
        {% if verbose %}
            {action_respond_info("Klippain corrected the prime_line_purge_distance to %.4f mm" % prime_line_purge_distance)}
        {% endif %}
    {% endif %}

    # We then compute the height to width ratio and validate that the prime line will not be too thin
    {% if (prime_line_height / line_width) >= 0.5 %} # TODO: validate this 1/2 ratio is good for all
        {action_raise_error("The prime line will be too thin and will probably not stick properly to the bed. Increase its purge distance or decrease its length!")}
    {% endif %}

    # Finally we compute the speed to get the correct flowrate for the prime line
    {% set speed = (prime_line_flowrate / (prime_line_height * line_width)) * 60 |float %}

    {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE=0
    {% endif %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
        {% endif %}
    {% endif %}

    G91
    M83
    {% if (printer.toolhead.position.z < 5) %}
        G1 Z5 F{Sz}
    {% endif %}

    # Starting position
    G90
    G0 X{prime_line_x} Y{prime_line_y} F{St}
    G1 Z{prime_line_height} F{Sz|int / 2}

    # Add pressure in the nozzle
    G92 E0
    G1 E18 F300

    # Prime line
    G92 E0
    {% if prime_line_direction == "X" %}
        G1 X{prime_line_x + prime_line_way*prime_line_length} E{prime_line_purge_distance} F{speed}
    {% elif prime_line_direction == "Y" %}
        G1 Y{prime_line_y + prime_line_way*prime_line_length} E{prime_line_purge_distance} F{speed}
    {% else %}
        { action_respond_error("Prime line direction is not valid. Choose either X or Y in the variables.cfg file!") }
    {% endif %}

    # Retract and Z-hop
    G92 E0
    G1 E-0.2 F2100
    G92 E0
    G1 Z3 F{Sz}

    # Additional small movement to get out of the line as some slicers directly emmit
    # a Z- move as a first step that make the toolhead crash back in the line and get dirty
    G91
    G1 X2 Y2 F{St}
    G90
    
    # Flushing Klipper's buffer to ensure the primeline sequence is done before continuing
    M400

[gcode_macro Prime_Line2]
gcode:
    G1 Z2 F6000
    G1 X-3  Y0  F12000
    G1 Z0.3
    G1 X55 E10 F1000
    G1 X90 E5 F1000
    G1 X120 E2 F1000
    G92 E0.0             ;set extruder to Zero

#------------------------------------------------------------------------------------------
